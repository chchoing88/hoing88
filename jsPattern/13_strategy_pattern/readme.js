/**
 * 전략 패턴
 * 
 * 전략 패턴은 특정 작업을 수행하는 다중 알고리즘, 즉 전략을 런타임 시 넣었다 뺐다 할 수 있는 모듈 단위로
 * 나누기 위해 사용한다. 이 장에서는 알고리즘을 사용하는 클라이언트, 즉 콘텍스트(context)에 상관없이 전략으로 알고리즘을
 * 추가 / 삭제하는 방법을 알아보자. 
 * 그리고 전략을 인터페이스화하여 프로그래밍 하면 전략을 사용하는 코드의 테스트성과 믿음성이 좋아지는 이유를 설명한다.
 * 
 * 
 * 예약을 진행하는 transportScheduler 에서는 집계서비스 인스턴스와 회사모듈을 생성하는 factory 인스턴스를
 * 받아서 예약을 진행하는 객체를 반환한다.
 * 
 * 이 객체는 해당 예약 정보를 받으면 해당 정보를 회사 모듈을 만드는 factory의 create 메서드에 전달한다.
 * 그럼 반환된 company 모듈은 schedulePickup 를 호출해서 예약을 진행한다.
 * 
 * 하여 모든 회사 모듈에서 schedulePickup 을 구현해두어야 하고 각 회사모듈이 각자의 전략을 가지고 모듈화를
 * 만들 수 있다. 
 * 
 * 회사가 늘어나면 회사 모듈을 생성하는 factory 함수만 건드리면 되고 
 * transportScheduler는 자신이 어느 회사 모듈을 사용하는지 전혀 몰라도 된다. 
 * 
 * 특정작업을 수행하는 서로 다른 알고리즘(운수회사 교통편 예약)을 분리하고, 런타임 시점에 알고리즘, 즉 
 * 전략을 동적으로 지정할 수 있게 해준 전략 패턴을 공부
 * 
 * 운수회사 모듈이 나중에 점점 늘어나도 사용자가 원하는 운송 타입에 해당하는 모듈 인스턴스를 적절히 제공하게끔
 * transportCompanyFactory를 확장하면 된다.  
 * 
 * transportScheduler.js 파일을 보라.
 */